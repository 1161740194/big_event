<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // var name = 'global';
        // var obj = {
        //     name: 'local',
        //     foo: function () {
        //         this.name = 'foo'; //  改变window的值
        //     }.bind(window)   // 改变this指向
        // };
        // var bar = new obj.foo();  // new的过程产生实例，this指像这个bar实例，因为bind触发this指向window
        // setTimeout(function () { // 因为是异步的上面代码执行完，在执行异步的任务，
        //     console.log('window', window.name); // foo2
        // }, 0);
        // console.log('bar', bar.name);  // foo
        // var bar3 = bar2 = bar; // 因为赋值操作浅拷贝不会改变他的地址，bar3 ,bar2 指向bar的地址
        // bar2.name = 'foo2'; // foo2
        // console.log('bar3', bar3.name); // foo2


        // class Person {
        //     constructor(name) {
        //         this.name = name;
        //     }
        //     greet() {
        //         console.log(`Hi, my name is ${this.name}`);
        //     }
        //     greetDelay(time) {
        //         setTimeout(() => {
        //             console.log(`Hi, my name is ${this.name}`);
        //         }, time);
        //     }
        // }

        // function Person(name){
        //     this.name = name
        // }
        // Person.prototype.greet = function (){
        //     console.log('Hi, my name is' + this.name);
        // }
        // Person.prototype.greetDelay = function (time){
        //     setTimeout(function (){
        //         console.log('Hi, my name is' + this.name);
        //     }, time);
        // }
        // function fn(n) {
        //     if (n == 0 || n == 1) return n
        //     return fn(n - 1) + fn(n - 2)
        // }
        // console.log(fn(4));
    </script>
</body>

</html>